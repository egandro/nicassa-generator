/* tslint:disable:max-line-length */
////////////////////////////////////////////////////////////////////
//
// GENERATED CLASS
//
// DO NOT EDIT
//
////////////////////////////////////////////////////////////////////

let unirest = require('unirest');
import { Configuration } from './configuration';

import {<%
referenceTypes.forEach(function(refType){%>
    <%- refType.name%>,<%}
);%>
} from './entities';
<%controllers.forEach(function(ctrl){
    var needEncodeURI = false;%>
export class <%- ctrl.name%>Service {
    private actionUrl: string;
    private proxyUrl: string;
    private timeout: number;
    private strictSSL: boolean;

    constructor(private _configuration: Configuration) {
        this.actionUrl = this._configuration.url() + '<%- ctrl.path%>';
        this.proxyUrl = this._configuration.proxyUrl();
        this.timeout = this._configuration.timeout();
        this.strictSSL = this._configuration.strictSSL();
    }
<% ctrl.methods.forEach(function(method){
%>
    public <%- method.name%>(<%
        var p=0;
        method.parameters.forEach(function(param){
            if((method.getPath("Client").indexOf("urlEncode")) >-1) {
                needEncodeURI = true;
            }
%><%- param.name%>: <%- param.type.name%><%
    if(p+1<method.parameters.length) {%>, <%
}%><%p++;});%>): Promise<<%if(method.type.isArray) {%><%- method.type.elementType.name%>[]<%} else {%><%- method.type.name%><%}%>> {<%
        if(method.needsBody()) {%>
        let body: any = '';<%if(
            method.bodyParamName) {%>
        body = <%- method.bodyParamName%>;<%}%>
<%}%>
        let promise = new Promise<<%if(method.type.isArray) {%><%- method.type.elementType.name%>[]<%} else {%><%- method.type.name%><%}%>>((resolve, reject) => {
            let request = unirest.<%- method.method%>(this.actionUrl + '<%- method.getPath("Client")%>');
            this.setBaseParams(request);<%
            if(method.needsBody()) {%>
            request.send(JSON.stringify(body));<%
            }%>
            request.end((response: any) => {
                if (response.status >= 400) {
                    reject(new Error(response.error));
                    return;
                }
                if (response.status === undefined || response.status === null) {
                    reject(new Error(response.error));
                    return;
                }<%if(method.type.isPrimitive){%>
                resolve(response.body);<%
               }else{%>
               let obj: any;
                try{
                    obj = JSON.parse(response.body);
                } catch (err) {
                    this.configuration.handleError(err);
                    reject(new Error(response.error));
                    return;
                }
                resolve(obj);<%
                }%>
            });
        });

        return promise;
    }
<%});%><%if(needEncodeURI) {%>
    private urlEncode(param: any): string {
        if( param === undefined || param === null) {
            return '';
        }
        return encodeURI(param);
    }<%
}%>

    private setBaseParams(unirest: any): any {
        if( unirest === undefined || unirest === null) {
            return unirest;
        }

        unirest = unirest.headers( {
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        });

        if(this.timeout !== undefined && this.timeout !== null && this.timeout>0) {
            unirest = unirest.timeout(this.timeout);
        }

        if(this.proxyUrl !== undefined && this.proxyUrl !== null ) {
            unirest = unirest.proxy(this.proxyUrl);
        }

        if(this.timeout !== undefined && this.strictSSL !== null && !this.strictSSL) {
            unirest = unirest.strictSSL(false);
        }

        return unirest;
    }
}
<%});%>
